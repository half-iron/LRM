
""" The xl2parser.py module contain tools for parsing logging and report text files generated by the NTiXL2 device.

The NTiXL2 device save report and logging files in .txt format.

"""

from datetime import datetime


def parse_broadband_file(file_path, options={}):
    """

    Parameters
    ----------
    file_path
        The location of the broadband recording file to be parsed

    Returns
    -------
    dict
        A dictionary organized in sections containing metadata and a section for measurements

    """
    broadband_section_functions = {"Hardware Configuration": __parse_hardware_section,
                                   "Measurement Setup": __parse_measurement_setup_section,
                                   "Time": __parse_time_section,
                                   "Broadband LOG Results": __parse_broadband_data_section,
    }

    return __parse_file(file_path, broadband_section_functions)


def __parse_file(file_path, function_dict):
    # Split up data into sections
    with open(file_path) as file:
        raw_sections = file.read().split('#')

    sections = {}
    first_line = raw_sections.pop(0).split('\n')[0].split('\t')
    sections['Title'] = first_line[0][:-1]
    sections['Measurement'] = {'file':((first_line[2]).split("\\")[1]).strip()}

    for section in raw_sections:
        # Split up sections into lines to parse
        lines = [line for line in section.split('\n\t')]
        section_title = lines.pop(0).strip()
        sections[section_title] = lines

    for key, f in function_dict.items():
        sections[key] = f(sections[key])

    sections['Measurement'].update(sections.pop('Time'))

    return sections

def __line_to_list(line):
    return [__try_parse_cell_content(e.strip()) for e in line.split('\t')]

def __try_parse_cell_content(s):
    if s == "":
        return None
    else:
        try:
            return int(s)
        except:
            try:
                return float(s)
            except :
                return s

def __parse_hardware_section(section_lines):
    splitted_lines = [l.split('\t') for l in section_lines if l  is not ""]
    hardware_dict = {k.strip().replace(':',''): v.strip()  for k,v in splitted_lines }
    value, unit = hardware_dict.pop('Mic Sensitivity').split(" ")
    hardware_dict['Mic Sensitivity[{}]'.format(unit)] = float(value)
    return hardware_dict


def __parse_measurement_setup_section(section_lines):
    splitted_lines = [l.split('\t') for l in section_lines if l  is not ""]
    setup_dict = {k.strip().replace(':',''): v.strip()  for k,v in splitted_lines }

    value1,_,value2, unit = setup_dict.pop('Range').split(" ")
    setup_dict['Range[{}]'.format(unit)] = [float(value1), float(value2)]
    return setup_dict


def __parse_time_section(section_lines):
    section_dict = {}
    for line in section_lines:
        splits = line.split('\t')
        if len(splits) != 2: continue
        section_dict[splits[0].strip().replace(':', '')] = datetime.strptime(splits[1].strip(), '%Y-%m-%d, %H:%M:%S')  # format to match: 2016-06-28, 20:05:08
    return section_dict


def __parse_broadband_data_section(section_lines):
    colnames = __line_to_list(section_lines.pop(0))
    colnames_index={name:n for n,name in enumerate(colnames)}
    num_cols= len(colnames)
    units = __line_to_list(section_lines.pop(0))

    if 'Pause' in colnames:
        units[colnames.index('Pause')] = "[?]" # to correct the missing PAUSE unit

    assert len(units)==num_cols

    #samples
    samples = {}
    samples_header_index = list(range(len(colnames)))



    columns_to_remove = ['Date','Time','Timer']
    #events handling
    evt_columns = [h for h in colnames if "Evt" in h]
    event = len(evt_columns) != 0
    if event:
        #remove events columns from output
        events_colnames= ["Evt_Duration","Evt_Key1","Evt_Key2","Evt_Key3","Evt_Key4","Evt_WaveFile"]
        columns_to_remove += ["Evt_Duration","Evt_Lvl","Evt_Key1","Evt_Key2","Evt_Key3","Evt_Key4","Evt_WaveFile"]
        events = {}
    else:
        events=None

    date_index = colnames_index['Date']
    time_index = colnames_index['Time']
    #samples headers
    selected_colnames=[name for name in colnames if name not in columns_to_remove]
    selected_colnames_index=[colnames_index[name] for name in selected_colnames]

    last_evt=-1
    evt={}
    ## iterate on rows
    for line in section_lines:
        elements = __line_to_list(line)

        #compute timestamp
        date = datetime.strptime(elements[date_index], '%Y-%m-%d').date()
        time = datetime.strptime(elements[time_index], '%H:%M:%S').time()
        timestamp = datetime.combine(date,time)

        #filter elements
        samples[timestamp] = [elements[i] for i in selected_colnames_index ]

        #events
        if event:
            try:
                event_n = int(elements[colnames_index['Evt_No']])
            except:
                event_n = None
            else:
                if event_n>last_evt:
                    evt={}
                    last_evt= event_n
                    evt['start']= timestamp
                    evt['Evt_No']=event_n
                    evt['key'] = ["Evt_Key1","Evt_Key2","Evt_Key3","Evt_Key4"]

                Evt_waw = elements[colnames_index['Evt_WaveFile']]

                #last event line contains the wav locatione
                if (Evt_waw is not None) and (".wav" in Evt_waw):
                    evt["Evt_WaveFile"] = Evt_waw
                    evt["Evt_Duration"] = elements[colnames_index['Evt_Duration']]
                    events[event_n]=evt

    return {"samples_columns":selected_colnames,
            "samples_units": [units[i] for i in selected_colnames_index],
            "samples":(samples),
            "events": events
            }



#
#
# def __parse_spectrum_data_section(section):
#     section[1] = section[1].replace('[dB]', 'Hz [dB]')
#     samples = __parse_broadband_data_section(section)
#     for sample in samples:
#         sample.pop('Band [Hz]',None)
#     for sample in samples:
#         freq_vs_label = {}
#         for key in sample.keys():
#             if '[dB]'  in key:
#                 freq_vs_label[__try_parse_cell_content(key.split()[0])] = key
#         sample['Spectrum_Frequencies [Hz]'] = []
#         sample['Spectrum_LZeq_dt_f [dB]'] = []
#         sorted_keys = list(freq_vs_label.keys())
#         sorted_keys.sort()
#         for key in sorted_keys:
#             sample['Spectrum_Frequencies [Hz]'].append(key)
#             sample['Spectrum_LZeq_dt_f [dB]'].append(sample[freq_vs_label[key]])
#         for key in freq_vs_label.values():
#             sample.pop(key, None)
#
#     return samples



# def parse_spectrum_file(file_path):
#     """
#
#     Parameters
#     ----------
#     file_path
#         The location of the broadband recording file to be parsed
#
#     Returns
#     -------
#     dict
#         A dictionary organized in sections containing metadata and a section for measurements
#
#     """
#     spectrum_section_functions = { "Hardware Configuration": __parse_hardware_section,
#                                    "Measurement Setup": __parse_measurement_setup_section,
#                                    "Time": __parse_time_section,
#                                    "sPECTRUM LOG Results": __parse_broadband_data_section,
#     }
#     return __parse_file(file_path, spectrum_section_functions)
